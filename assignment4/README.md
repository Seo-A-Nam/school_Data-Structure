# 생각해볼 것

1. process_input()에서
    // 일단 ( , ) 형식 체크는 생략해둠. 나중에 보완하기.
    // 만약 (계수, 차수)의 순서가 뒤죽박죽이면 어떡할까? 오름차순이 아니라면
    // 정렬해서 그냥 그대로 쓰기? 아니면 원래꺼와 정렬된 거 비교 후 에러 출력?
    // 똑같은 계수가 중복 입력된다면?
2. 동차항 반복이나 그럴 경우 예외처리를 해줘야하는데 그걸 bool로 리턴받아 처리해야하나?

3. 식 출력 형식
* 상수항(차수 0)일 경우 1이 나오는 지 체크 (주의)
* 상수항이 아닌데 계수가 1일 경우는 1이 나오지 않도록함 (1x -> 틀림, x -> 맞음)
* 상수항(차수 0) 뒤에 x가 안붙도록 함
* 계수가 1차 일때는 x 뒤에 제곱 안붙임

4. 
    만약 곱셈의 인자로 자기 자신을 넣어줬다면? :  -> 이 부분까지 처리해야하나?
    -> 연산자 오버로딩 하니까 잘 되는 것 같다.
    <!-- ex)   t.MultPoly(a,b);
        cout<<t<<endl;
        t.MultPoly(t,b);
        cout<<t<<endl;
        이 경우 a = 2x+1, b = 3을 넣었을 때, 첫번째 출력에서는 6x+3 이 나온다.
        그렇지만 다시 자기자신을 인자로 넣은 두번째 출력에서는 18x+9가 아닌 덮어쓰기 전의 기존의 값까지 더해진 24x+12가 된다.
        따라서 그럴 경우는 결과값을 넣어줄 기존의 메모리를 변수 c에 백업해둔 후, 원본 a는 지워버리고 따로 b와 c(복제본)로 연산해준다?
        -> 처리하려고 해봤는데 뭔가 잘 안되는 것 같다. -->


5. "this" 관련해서 정리하기

6. addPoly()에서
처음에 (최고차수 - 최저차수) 만큼 while을 돌도록 했을 때,
if (i == size1 && j == size2) 
            break;
// 이거 안해주면 쓰레기값 들어감... 왜 해줘야하는지 알아보자.
인덱스를 직접 계산해서 확인해봐야겠다.
아마도 => 매번 한차수씩 돌아가며 확인하는게 아니라 현재 나오는 차수 중에서 하나씩/(차수 같다면 두개씩) 뽑아오기 때문에 (최고차수 - 최저차수)보다 더 빨리 끝날 수도 있겠다.
    -> 결국 수정함. while(1)으로 무한루프 돌고 브레이크 조건에서 빠지게끔.
    -> 사실 (최고차수 - 최저차수)를 구해서 그만큼 돌 필요조차 없었다. 그것들 구하는 함수 둘다 지움

7. 연산자 오버로딩에서 "<<" 표준입력 오버로딩의 경우에는 private 멤버변수에 저장해야하므로 friend 멤버함수로 추가해주었음.

8. process_input()에서 입력된 게 문자열인지 숫자인지 예외처리하는 것도 해야하나?

9. "0" 처리
주의 : 입력 값에서 3x^2 + 0 이렇게 받아도 따로 예외처리 안하고 0만 제거해서 3x^2 이렇게 들어가게 해줌.

디버깅 : 
이런 식으로 0을 넣었을 때 0이 출력되지 않도록 하려면 어떻게 해야하나?
☁  assignment4 [master] ⚡  ./a.out           
(0,0)(0,0) (3,2)(0,0) (0,0) 1
[error] duplicated homogenious
A(x) = 0+0
B(x) = 3x^2+0
C(x) = 0
T(x) = 0x^2+0x^2+0+0
D(x) = 0x^2+0x^2+0
x = 1-->0%     

11. 음수인 계수 처리 (출력)
+ 가 꼭 나오는데 이때 +-3x^7이건 좀 어색하고, +(-3)x^7 이런 식으로 괄호를 묶어야한다.
☁  assignment4 [master] ⚡  ./a.out           
(1,1)(1,2)(3,5)
(-2,3)(-1,2)
(1,0)
A(x) = 3x^5+x^2+x
B(x) = -2x^3+-1x^2
C(x) = 1
T(x) = -6x^8+-3x^7+-2x^5+-3x^4+-1x^3
D(x) = -6x^8+-3x^7+-2x^5+-3x^4+-1x^3+1
1
x = 1-->-14%      